#include PLATFORM_HEADER
#include "app_process.h"
#include "stack/include/ember.h"
#include "hal/hal.h"
#include "em_chip.h"
#include "app_log.h"
#include "sl_app_common.h"
#include "app_framework_common.h"
#include "sl_simple_led_instances.h"
#include "app_process.h"
#include "em_cmu.h"
#include "em_emu.h"
#include "em_eusart.h"
#include "app_ipc.h"

volatile uint8_t ipcRxBuffer[IPC_RX_MAX_SIZE];
volatile uint8_t ipcTxBuffer[IPC_TX_MAX_SIZE];
volatile uint32_t ipcRxPos = 0;
volatile uint32_t ipcTxLen = 0;
volatile bool ipcDataReady = false;
volatile bool ipcRespReady = false;
uint8_t tmpRxBuffer[IPC_RX_MAX_SIZE];

void EUSART1_RX_IRQHandler(void)
{
  ipcRxBuffer[ipcRxPos] = EUSART1->RXDATA;

  if ((ipcRxBuffer[ipcRxPos] != '\r') && (ipcRxPos < IPC_RX_MAX_SIZE))
    ipcRxPos++;
  else {
      ipcDataReady = true;
      EUSART_IntDisable (EUSART1, EUSART_IEN_RXFL);
      EUSART_IntEnable (EUSART1, EUSART_IEN_TXFL);
  }
  EUSART_IntClear(EUSART1, EUSART_IF_RXFL);
}

void EUSART1_TX_IRQHandler(void)
{
  if (ipcRespReady)
    {
      for (uint32_t i = 0; i < ipcTxLen; i++)
        {
          EUSART1->TXDATA = tmpRxBuffer[i];

        }
      EUSART_IntClear (EUSART1, EUSART_IF_TXFL);
      ipcRespReady = false;
      EUSART_IntEnable (EUSART1, EUSART_IEN_RXFL);
      EUSART_IntDisable (EUSART1, EUSART_IEN_TXFL);

    }


}
void ipcRxHandler(void){

  memcpy((volatile *)tmpRxBuffer, ipcRxBuffer, ipcRxPos);
  app_log_info("Input: %s \n", ipcRxBuffer);
  app_log_info("Output: %s \n", tmpRxBuffer);
  ipcTxLen = ipcRxPos;
  ipcRxPos = 0;
  ipcDataReady = false;
  ipcRespReady = true;
  switch(tmpRxBuffer[0]){

  }
}
