#include PLATFORM_HEADER
#include "app_process.h"
#include "stack/include/ember.h"
#include "hal/hal.h"
#include "em_chip.h"
#include "app_log.h"
#include "sl_app_common.h"
#include "app_framework_common.h"
#include "sl_simple_led_instances.h"
#include "app_process.h"
#include "em_cmu.h"
#include "em_emu.h"
#include "em_eusart.h"
#include "app_ipc.h"

volatile uint8_t ipcRxBuffer[IPC_RX_MAX_SIZE];
volatile uint8_t ipcTxBuffer[IPC_TX_MAX_SIZE];
volatile uint32_t ipcRxPos = 0;
volatile uint32_t ipcTxLen = 0;
volatile bool ipcDataReady = false;
volatile bool ipcRespReady = false;
volatile uint8_t tmpRxBuffer[IPC_RX_MAX_SIZE];
volatile uint32_t offset = 0;
osThreadId_t ipcId;

void EUSART1_RX_IRQHandler(void)
{
  ipcRxBuffer[ipcRxPos] = EUSART1->RXDATA;

  if ((ipcRxBuffer[ipcRxPos] != 0xFA) && (ipcRxPos < IPC_RX_MAX_SIZE))
    {
      ipcRxPos++;
    app_log_info("Data: 0x%02X", ipcRxBuffer[ipcRxPos]);
    }

  else if (ipcRxBuffer[ipcRxPos] == 0xFA){
      ipcDataReady = true;
  }
  EUSART_IntClear(EUSART1, EUSART_IF_RXFL);
}

void EUSART1_TX_IRQHandler(void)
{
  app_log_info("running tx, %d", ipcTxLen);
  EUSART_IntClear (EUSART1, EUSART_IF_TXFL);

  if (ipcTxLen > 14)
    {
      for (uint32_t i = 0 + offset; i < 13 + offset; i++)
        {
          EUSART1->TXDATA = ipcTxBuffer[i];

        }
      offset+=13;
      ipcTxLen-=13;
    }
  else if (ipcTxLen <= 14){
      for (uint32_t i = 0; i < 14; i++)
        {
          EUSART1->TXDATA = ipcTxBuffer[i];
        }
      ipcRespReady = false;
            EUSART_IntEnable (EUSART1, EUSART_IEN_RXFL);
            EUSART_IntDisable (EUSART1, EUSART_IEN_TXFL);
            offset = 0;
  }

}
void ipcRxHandler(void){
  app_log_info("running handler");
  ipcRxPos = 0;

  switch (tmpRxBuffer[0])
    {
    default:
      {
        app_log_info("running switch");

        uint8_t tmpTxIndex = 0;
        for(uint8_t i = 0; i < sensorIndex; i++){
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) sensorInfo[i].hw;
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) sensorInfo[i].state;
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) (sensorInfo[i].battery_voltage >> 24);
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) (sensorInfo[i].battery_voltage >> 16);
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) (sensorInfo[i].battery_voltage >> 8);
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) sensorInfo[i].battery_voltage;
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) sensorInfo[i].node_type;
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) (sensorInfo[i].central_id >> 8);
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) sensorInfo[i].central_id;
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) (sensorInfo[i].self_id >> 8);
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) sensorInfo[i].self_id;
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) sensorInfo[i].endpoint;
            ipcTxBuffer[tmpTxIndex++] = 0xFF & (uint8_t) sensorInfo[i].trigd;
        }
        ipcTxBuffer[tmpTxIndex++] = (uint8_t) (13 * sensorIndex);
        app_log_info("len: %d \n", ipcTxLen);
        ipcTxLen = tmpTxIndex;
        app_log_info("Info: 0x%02X", ipcTxBuffer);
        break;
      }
    case IPC_ACK:
      {
        break;
      }

    }
  ipcRespReady = true;
  EUSART_IntDisable (EUSART1, EUSART_IEN_RXFL);
  EUSART_IntEnable (EUSART1, EUSART_IEN_TXFL);
  ipcDataReady = false;
}

void ipcNotify(void){

}

void ipcInitThread(void){
  osThreadAttr_t ipcStackAttribute = {
      "Inter Processor Communication Task",
      osThreadDetached,
      NULL,
      0,
      NULL,
      (1000 * sizeof(void *)) & 0xFFFFFFF8u,
      38,
      0,
      0
    };


    ipcId = osThreadNew(ipcRtosTask,
                                 NULL,
                                 &ipcStackAttribute);
    assert(ipcId != 0);
}

void ipcRtosTask(void *p_arg)
{
  (void)p_arg;

  startIPC();

  while (true) {
      ipcRxPos++;
    //app_log_info("rtos");
      if(ipcDataReady){
          ipcRxHandler();
      }
      osDelay(10);
  }
}

