{"html":"\n      <article>\n        <p class=\"banner\"><a href=\"http://docs.silabs.com/gecko-platform/4.0/service/cli/overview\" target=\"_blank\" title=\"http://docs.silabs.com/gecko-platform/4.0/service/cli/overview\">Open in Browser<\/a><\/p><h1 id=\"command-line-interface-cli\">Command Line Interface (CLI)<\/h1><h2 id=\"introduction\">Introduction<\/h2><p>The Command Line Interface (CLI) software component simplifies creating command line user interfaces for programs. It handles tasks such as receiving keyboard input, parsing the input strings for commands and arguments, and calling the proper C function with decoded and validated arguments. Functions can use standard output functions such as printf to write information to the console.<\/p><p>Multiple components (parts of an application) may define CLI commands, where the running program will typically merge all commands into a superset of commands with common input and output, I/O. The CLI uses I/O functions provided by the I/O Streams framework, iostream.<\/p><p>The CLI component supports multiple instances, where separate CLI instances will use separate iostream instances. Groups of commands can be assigned to specific CLI instances making it possible for one application to use multiple CLI instances, where each is customized for its particular use.<\/p><h1 id=\"content\">Content<\/h1><ul>\n<li><a href=\"#features\">Features<\/a><\/li><li><a href=\"#design\">Design<\/a><\/li><li><a href=\"#configuration\">Configuration<\/a><\/li><li><a href=\"#examples\">Examples<\/a><\/li><li><a href=\"#extensions\">Extensions<\/a><\/li><\/ul>\n<h1 id=\"features\">Features<\/h1><p>The CLI has several built in features that will be inherited by all applications using the CLI component. The following sections explain some of the CLI features.<\/p><p><strong>Note:<\/strong> Some features can be simplified or removed to reduce code size by changing the application configuration.<\/p><h2 id=\"command-groups\">Command Groups<\/h2><p>The CLI supports both stand alone commands and commands that belong to groups. A stand alone command is executed by typing the command name and arguments. If a command belongs to a group, the group name must be typed before the command name. Groups can be nested, and in that case, all group names must be typed before the command name.<\/p><p>If an application has implemented the commands <code>on<\/code> and <code>off<\/code> that are part of the groups <code>green<\/code> and <code>red<\/code> in group <code>led<\/code>, the user can type: <code>led green on<\/code> or <code>led red off<\/code> to control the LEDs.<\/p><h2 id=\"help\">Help<\/h2><p>The CLI has a built in help command, which can be used as follows:<\/p><p>By typing <code>help<\/code>, all commands are listed.<\/p><p>By typing <code>help group<\/code>, all commands in the <code>group<\/code> are listed.<\/p><p>By typing <code>help command<\/code>, help for the <code>command<\/code> is shown.<\/p><p>The information that is displayed when using the <code>help<\/code> command must be supplied by the implementer. Details for each command must be placed in command tables. See the <a href=\"#command-tables\">Command tables<\/a> section for more details.<\/p><h2 id=\"autocomplete\">Auto-Complete<\/h2><p>The CLI can complete a partially typed command by pressing the TAB key.<\/p><h2 id=\"cursor-movement\">Cursor Movement<\/h2><p>The up-arrow and down-arrow keys can be used to navigate up and down in the history buffer.<\/p><p>The left-arrow and right-arrow keys are used to move the cursor in the current command line. The BACKSPACE key is used to delete the character to the left of the cursor. The DEL key is used to delete the character under the cursor. Typed characters will be inserted at the cursor position.<\/p><h2 id=\"command-history\">Command History<\/h2><p>Commands are stored in the history buffer when executed. Previous commands can be executed again by pressing the up-arrow key one or more times.<\/p><p><strong>Note:<\/strong> The history buffer is a simple character array, which does not define how many command lines can be stored. The history buffer stores command lines sequentially, making room for more short commands than long.<\/p><h2 id=\"dynamic-registration-of-new-commands\">Dynamic Registration of New Commands<\/h2><p>An application using the CLI component can define commands that must be installed either at compile time or at run time. Defining commands at compile time may be sufficient for simple applications, while more advanced applications with several CLI instances, may utilize that the CLI can add command groups at run time.<\/p><h2 id=\"central-decoding-and-validation-of-command-arguments\">Central Decoding and Validation of Command Arguments<\/h2><p>The CLI has built in functions to decode and validate command arguments. The command handler will not be called unless the command is entered with correct arguments.<\/p><p>The CLI argument validation can handle signed and unsigned numeric values with 8, 16 and 32 bit sizes, hexadecimal and string arguments. The command handler will be called with decoded arguments using an <code>argc, argv<\/code> pattern similar to how C/C++ applications pass command line arguments to the main function.<\/p><p>If none of the built in argument types can be used by the command, it can use string arguments and decode the strings in the command handler.<\/p><p><strong>Note:<\/strong> For the last argument, it is possible to specify that it is optional, mandatory or can have multiple values.<\/p><h2 id=\"input-and-output\">Input and Output<\/h2><p>The CLI is using iostreams for input and output. Each CLI instance must have a dedicated iostream instance.<\/p><p>Assigning an iostream instance to a CLI instance is usually done with an application configuration. If the application has only one CLI and one iostream instance, the configuration will automatically assign the iostream instance to the CLI instance.<\/p><h2 id=\"requirements-not-defined-by-the-cli\">Requirements not Defined by the CLI<\/h2><p>Command naming rules or output formats are not defined by the CLI.<\/p><h1 id=\"design\">Design<\/h1><p>To fully understand how to use the CLI, it is crucial to understand the design and some implementation details. The following sections will try to explain the basics and how to create user commands.<\/p><h2 id=\"modules\">Modules<\/h2><p>The CLI has been implemented as two independent software modules; <code>input handler<\/code> and <code>command interpreter<\/code>. The <code>input handler<\/code> handles the user input and allows the user to enter command lines. When the user types the ENTER key, the input string is passed to the <code>command interpreter<\/code> where the string will be interpreted and the appropriate command handler will be called with the command arguments.<\/p><p>Normally both modules are used together, but an application can use the <code>command interpreter<\/code> directly. In that case, the <code>command interpreter<\/code> must be called with a command line as input parameter.<\/p><h2 id=\"command-signature\">Command Signature<\/h2><p>All command handlers must have the same signature, defined in <code>sl_cli_types.h<\/code>:<\/p><pre><code>typedef void (*sl_cli_command_func_t)(sl_cli_command_arg_t *arguments);<\/code><\/pre><h2 id=\"command-arguments\">Command Arguments<\/h2><p>Command arguments are available via the arguments pointer passed to the command handler function.<\/p><p>The arguments pointer will point to a struct, which holds the argument values.<\/p><p>The arguments struct has the following definition:<\/p><pre><code>typedef struct {\n  struct sl_cli *handle;        ///&lt; The current CLI handle.\n  int argc;                     ///&lt; The total number of input strings (command group names, if any + command + corresponding arguments).\n  void **argv;                  ///&lt; A pointer to the input string array.\n  int arg_ofs;                  ///&lt; The offset in the input string array where the arguments start (after the command group names, if any and command).\n} sl_cli_command_arg_t;<\/code><\/pre><p>The <code>handle<\/code> identifies the CLI instance where the command was issued. By including the instance handle, it is possible to share the same command handler between multiple CLI instances.<\/p><p>By using the <code>argc<\/code>, <code>argv<\/code> way of passing argument values, it is possible to have a common command handler signature but support variable number of arguments.<\/p><p>When the command handler is called, the <code>argc<\/code>, <code>argv<\/code> arguments will contain all commands and arguments. Because the CLI supports command groups, the command may consist of multiple command groups along with the command itself. The <code>arg_ofs<\/code> tells the command handler the offset where the command arguments begin.<\/p><p>The cli.h has defined the following macros that can be used to get argument values. The macros use <code>a<\/code> for the arguments pointer and <code>n<\/code> for the argument offset, starting on 0 for the first argument.<\/p><pre><code>sl_cli_get_argument_int8(a, n)\nsl_cli_get_argument_int16(a, n)\nsl_cli_get_argument_int32(a, n)\nsl_cli_get_argument_uint8(a, n)\nsl_cli_get_argument_uint16(a, n)\nsl_cli_get_argument_uint32(a, n)\nsl_cli_get_argument_hex(a, n, l)\nsl_cli_get_argument_string(a, n)<\/code><\/pre><h2 id=\"command-tables\">Command Tables<\/h2><p>Adding commands to the CLI requires using three different data structures. The data structures have a root node referred to as a \"command group\", where sub-structures defining command details are nested. The \"command group\" may contain details for one or more commands and it is possible to install multiple \"command groups\" in each CLI instance.<\/p><p>The \"command group\" must be of the type:<\/p><pre><code>typedef struct {\n  sl_slist_node_t node;\n  bool in_use;\n  const sl_cli_command_entry_t *command_table;\n} sl_cli_command_group_t;<\/code><\/pre><p><strong>Note:<\/strong> Each time a command group is installed in a CLI instance, the application must support one unique command group data structure. Command groups cannot be re-used or shared between CLI instances.<\/p><p>The next level is an array where each of the elements must be a \"command entry\". Typically one array element exists for each command. If a command has both a long and a short (shortcut) name, it will take two array elements.<\/p><p>Each of the \"command entries\" must be of the type:<\/p><pre><code>typedef struct {\n  const char                  *name;        ///&lt; String associated with command/group\n  const sl_cli_command_info_t *command;     ///&lt; Pointer to command information\n  const bool                  is_shortcut;  ///&lt; Indicating if the entry is a shortcut\n} sl_cli_command_entry_t;<\/code><\/pre><p>A \"command entries\" array can be re-used and shared between multiple CLI instances.<\/p><p>Finally, \"command information\" for commands is defined in one data structure for each command. The \"command information\" structure is defined with the following type:<\/p><pre><code>typedef struct {\n  sl_cli_command_func_t function;             ///&lt; Command function\n    #if SL_CLI_HELP_DESCRIPTION_ENABLED\n  char                   *help;               ///&lt; Info displayed by \"help\" command\n  char                   *arg_help;           ///&lt; Info for arguments.\n    #endif // SL_CLI_HELP_DESCRIPTION_ENABLED\n  sl_cli_argument_type_t arg_type_list[];     ///&lt; List of argument types\n} sl_cli_command_info_t;<\/code><\/pre><p>A \"command information\" data structure can be re-used and shared between multiple CLI commands and instances.<\/p><h2 id=\"command-handler\">Command Handler<\/h2><p>In addition to the tables described above, each command must have a command handler. The command handler is typically written in C-code, where all command handlers have the same signature. The command handler function prototype has the following definition:<\/p><pre><code>typedef void (*sl_cli_command_func_t)(sl_cli_command_arg_t *arguments);<\/code><\/pre><h2 id=\"differences-between-bare-metal-and-kernel-configurations\">Differences between Bare Metal and Kernel Configurations<\/h2><p>The CLI component can be used in both bare metal and kernel configurations. The differences between the two configurations are explained in the following sections.<\/p><p><strong>Bare Metal<\/strong><\/p><p>In a bare metal configuraton, the <code>input handler<\/code> has a process-action (tick) function that will poll the iostream for input. When generating a project with uc, the CLI process-action function will be installed into the system framework. Calling the <code>sl_system_process_action<\/code> function calls the CLI process-action function.<\/p><p><strong>Note:<\/strong> CLI command handlers that take a long time to execute can (should) return from the process-action function before they are complete to not stall other component process-action functions. Execution will in that case be split into several calls to the process-action function. The application should not make any assumptions about when any of the command handlers have completed execution based on when the <code>sl_system_process_action<\/code> returns.<\/p><p><strong>Kernel<\/strong><\/p><p>In a kernel configuration, the CLI will create a task where the <code>input handler<\/code> polls the iostream for input data. One task is created for each CLI instance. The task(s) must be started by the application by calling the <code>sl_system_kernel_start<\/code> function.<\/p><h1 id=\"configuration\">Configuration<\/h1><p>The CLI has two sets of configurations. One is common for all CLI instances and is placed in the <code>sl_cli_config.h<\/code> file. The other is a configuration file for each CLI instance with the file name <code>sl_cli_config_&lt;instance-name&gt;.h<\/code>.<\/p><h1 id=\"examples\">Examples<\/h1><p>The following steps demonstrate how to create and install a CLI command.<\/p><p><strong>Note:<\/strong> To avoid forward definitions in the C-code, the following steps will typically be implemented in reverse order.<\/p><p>Include the <code>cli<\/code> and <code>iostream<\/code> components to the project. Both <code>cli<\/code> and <code>iostream_usart<\/code> instances must specify instance names. The <code>iostream_usart<\/code> component has some pre-defined instance names while the <code>cli<\/code> instance name can be anything.<\/p><pre><code>component:\n  - id: cli\n    instance:\n    - example\n  - id: iostream_usart\n    instance:\n    - vcom<\/code><\/pre><p>Define and implement CLI commands:<\/p><pre><code>#include \"sl_cli.h\"\n\n// Create the command group at the top level\nstatic sl_cli_command_group_t a_group_0 = {\n  { NULL },\n  false,\n  a_table\n};\n\n// Create the array of commands, containing three elements in this example\nstatic sl_cli_command_entry_t a_table[] = {\n  { \"echo_str\", &amp;cmd__echostr, false },\n  { \"echo_int\", &amp;cmd__echoint, false },\n  { \"echo_intstr\",  &amp;cmd__echointstr, false },\n  { NULL, NULL, false },\n};\n\n// Create command details for the commands. The macro SL_CLI_UNIT_SEPARATOR can be\n// used to format the help text for multiple arguments.\nstatic const sl_cli_command_info_t cmd__echostr = \\\n  SL_CLI_COMMAND(echo_str,\n                 \"echoes string arguments to the output\",\n                 \"Just a string...\",\n                 {SL_CLI_ARG_WILDCARD, SL_CLI_ARG_END, });\n\nstatic const sl_cli_command_info_t cmd__echoint = \\\n  SL_CLI_COMMAND(echo_int,\n                 \"echoes integer arguments to the output\",\n                 \"Just a number...\",\n                 {SL_CLI_ARG_INT8, SL_CLI_ARG_ADDITIONAL, SL_CLI_ARG_END, });\n\nstatic const sl_cli_command_info_t cmd__echointstr = \\\n  SL_CLI_COMMAND(echo_intstr,\n                 \"echoes integer and string arguments to the output\",\n                 \"Just a number...\" SL_CLI_UNIT_SEPARATOR\n                 \"Just a string...\"\n                 {SL_CLI_ARG_INT8, SL_CLI_ARG_STRING, SL_CLI_ARG_END, });\n\n// Create command handlers for the commands\nvoid echo_str(sl_cli_command_arg_t *arguments)\n{\n  char *ptr_string;\n\n  for (int i = 0; i &lt; sl_cli_get_argument_count(arguments); i++) {\n    ptr_string = sl_cli_get_argument_string(arguments, i);\n    ...\n  }\n}\n\nvoid echo_int(sl_cli_command_arg_t *arguments)\n{\n  int8_t argument_value;\n\n  for (int i = 0; i &lt; sl_cli_get_argument_count(arguments); i++) {\n    argument_value = sl_cli_get_argument_int8(arguments, i);\n    ...\n  }\n}\n\nvoid echo_intstr(sl_cli_command_arg_t *arguments)\n{\n  int8_t argument_value;\n  char *ptr_string;\n\n  argument_value = sl_cli_get_argument_int8(arguments, 0);\n  ptr_string = sl_cli_get_argument_string(arguments, 1);\n  ...\n}\n\n// And finally call the function to install the commands.\n  status = sl_cli_command_add_command_group(cli_handle, &amp;a_group_0);<\/code><\/pre><p>The output from executing <code>help<\/code> will in this case be:<\/p><pre><code>&gt; help\n  echo_str                      echoes string arguments to the output\n                                [*] Just a string...\n  echo_int                      echoes integer arguments to the output\n                                [int8+] Just a number...\n  echo_intstr                   echoes integer and string arguments to the output\n                                [int8] Just a number...\n                                [string] Just a string...<\/code><\/pre><h1 id=\"extensions\">Extensions<\/h1><p>The CLI comes with some pre-made components that can be useful for some applications. To take advantage of these components, the user must:<\/p><ol>\n<li>Define the command(s) in the command tables. Use the command handlers supplied with the component(s).<\/li><li>Include the component(s) in the project.<\/li><\/ol>\n<p>The components come with the command handlers and integrate with the CLI. Most of the components however do not define the command name. Instead, it must be defined by the application implementer.<\/p><p><strong>Note:<\/strong> The CLI extensions described here use the method of splitting some of the command handler operations into multiple process-action calls for bare-metal configuration.<\/p><p><strong>Common properties for the storage components:<\/strong> The storage components share some common properties although data is stored in different locations. The most important are: New commands can be added, existing commands can be deleted and stored commands can be executed.<\/p><p>One benefit of running commands from a storage compared to typing the commands at user input is that the next command in the list will be executed immediately after the previous command has completed. Commands will be executed in the sequence they are added and stored, and there will be zero or little delay between commands.<\/p><h2 id=\"simple-password-protection\">Simple Password Protection<\/h2><p>The <code>cli_simple_password<\/code> component has been designed to provide functionalities to limit access to the CLI interface. It asks to configure a password at first startup and requires the configured password at the next access. It also includes security mechanisms to limit the number of attempts with invalid passwords. In other words, access is locked when the maximum number of retries is reached. If the retry limit is reached, a Security flag is raised and will be displayed on the login page until cleared. Depending on the device used, the key and the encrypted password are stored in the Secure Element or with NVM3.<\/p><p>The <code>cli_simple_password<\/code> component defines the following user commands and their associated handlers.<\/p><pre><code>sl_status_t sl_cli_simple_password_logout(sl_cli_handle_t handle);\nsl_status_t sl_cli_set_simple_password(char *new_password);\nsl_status_t sl_cli_simple_password_destroy_key(void);\nsl_status_t sl_cli_reset_security_warning_flag(void);<\/code><\/pre><pre><code>cli logout\ncli set_password &lt;current_password&gt; &lt;new_password&gt; &lt;new_password_confirmation&gt;\ncli destroy_key\ncli reset_security_flag<\/code><\/pre><h2 id=\"storage-nvm3\">Storage NVM3<\/h2><p>The <code>cli_storage_nvm3<\/code> component has been designed to store command lines in NVM3 storage. In addition to letting the user control when the commands are executed, the stored commands will automatically be executed at program start.<\/p><p>The <code>cli_storage_nvm3<\/code> component does not define the user commands. However, it implements a few functions where the following four are designed to be used as CLI command handlers directly.<\/p><pre><code>void sl_cli_storage_nvm3_clear(sl_cli_command_arg_t *arguments);\nvoid sl_cli_storage_nvm3_list(sl_cli_command_arg_t *arguments);\nvoid sl_cli_storage_nvm3_define(sl_cli_command_arg_t *arguments);\nvoid sl_cli_storage_nvm3_execute(sl_cli_command_arg_t *arguments);<\/code><\/pre><p>In addition, get the number of command lines stored in NVM3 storage by calling the following function:<\/p><pre><code>size_t sl_cli_storage_nvm3_count(sl_cli_handle_t cli_handle);<\/code><\/pre><p>The <code>cli_storage_nvm3<\/code> depends on the <code>cli_default<\/code> component that defines the NVM3 storage area. This area is typically shared between different parts of the application, where each has its own range of NVM3 object keys to avoid collisions. The <code>cli_storage_nvm3<\/code> component has a range with 256 keys.<\/p><p>You can configure each CLI instance to use a sub-set of the available 256 keys to separate commands between different CLI instances.<\/p><h2 id=\"storage-ram\">Storage RAM<\/h2><p>The <code>cli_storage_ram<\/code> component has been designed to store command lines in a ram buffer.<\/p><p>The <code>cli_storage_ram<\/code> component does not define the user commands. However, it implements a few functions where the following four are designed to be used as CLI command handlers directly.<\/p><pre><code>void sl_cli_storage_ram_clear(sl_cli_command_arg_t *arguments);\nvoid sl_cli_storage_ram_list(sl_cli_command_arg_t *arguments);\nvoid sl_cli_storage_ram_define(sl_cli_command_arg_t *arguments);\nvoid sl_cli_storage_ram_execute(sl_cli_command_arg_t *arguments);<\/code><\/pre><p>In addition, get the number of command lines stored in RAM by calling:<\/p><pre><code>size_t sl_cli_storage_ram_count(sl_cli_handle_t cli_handle);<\/code><\/pre><p>Each instance of the CLI will have its own RAM buffer. Commands defined in one CLI instance will not be available for other instances.<\/p><h2 id=\"delay\">Delay<\/h2><p>The <code>cli_delay<\/code> component may be useful to add delays between commands when running command sequences from storage. The function will delay for the specified number of milliseconds. During the delay, it will allow other components to run in the background.<\/p><p>The command handler has the following function prototype:<\/p><pre><code>void sl_cli_delay_command(sl_cli_command_arg_t *arguments);<\/code><\/pre>\n      <div ub-in-page=\"6062051aebaf71079a7b414b\"><\/div>\n      <\/article>\n    ","url":"http://docs.silabs.com/gecko-platform/4.0/service/cli/overview","status":"success"}
